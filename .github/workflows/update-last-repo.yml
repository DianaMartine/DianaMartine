# .github/workflows/update-last-repo.yml

# name of the workflow
name: Update Last Repo

# on which events the workflow should run
on:
  # schedule the workflow to run every day at 00:00 UTC
  schedule:
    # cron syntax for scheduling, minute, hour, day of month, month, day of week
    - cron: "0 0 * * *"
  # manually trigger the workflow
  workflow_dispatch:

# permissions to run the workflow
permissions:
  # allow the workflow to write to the repository
  contents: write
  # allow the workflow to write to pull requests
  pull-requests: write
  # allow the workflow to write to issues
  issues: write
  # allow the workflow to write to discussions
  discussions: write
  # allow the workflow to write to pages
  pages: write
  # allow the workflow to write to repository projects
  repository-projects: write

# define the jobs to be run in the workflow
jobs:
  # job to update the last repo
  update-last-repo:
    # runs on the latest version of Ubuntu
    runs-on: ubuntu-latest
    # steps to be run in the job
    steps:
      # checkout the repository
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Fetch last updated repo # Passo para buscar e formatar a informa√ß√£o
        run: |
          # --- Script para buscar o √∫ltimo repo atualizado ---
          # Este √© um script shell simples que usa a GitHub CLI (gh) ou curl
          # Voc√™ precisar√° ter a GitHub CLI instalada ou usar curl e jq

          # Instala a GitHub CLI (se n√£o estiver dispon√≠vel)
          sudo apt-get update && sudo apt-get install -y gh jq

          # Usa a GitHub CLI para buscar os reposit√≥rios ordenados por 'pushed' (√∫ltima atualiza√ß√£o)
          # Pega o primeiro (-L 1), seleciona os campos e formata como JSON
          REPO_DATA=$(gh repo list ${{ github.repository_owner }} --limit 1 --sort pushed --json name,description,htmlUrl,stargazerCount,language,pushedAt,isFork)

          # Processa o JSON para extrair as informa√ß√µes do √∫ltimo repo que N√ÉO SEJA UM FORK
          # Se voc√™ quiser incluir forks, remova a parte 'select(.isFork | not)'
          LAST_REPO_INFO=$(echo "$REPO_DATA" | jq -c 'map(select(.isFork | not)) | .[0]')

          # Verifica se encontrou um repo
          if [ -z "$LAST_REPO_INFO" ] || [ "$LAST_REPO_INFO" == "null" ]; then
            echo "Nenhum reposit√≥rio n√£o-fork encontrado ou erro ao buscar."
            echo "::set-output name=readme_content::N/A" # Define output vazio ou mensagem
          else
            REPO_NAME=$(echo "$LAST_REPO_INFO" | jq -r '.name')
            REPO_DESC=$(echo "$LAST_REPO_INFO" | jq -r '.description')
            REPO_URL=$(echo "$LAST_REPO_INFO" | jq -r '.htmlUrl')
            STAR_COUNT=$(echo "$LAST_REPO_INFO" | jq -r '.stargazerCount')
            LANGUAGE=$(echo "$LAST_REPO_INFO" | jq -r '.language')
            PUSHED_AT_ISO=$(echo "$LAST_REPO_INFO" | jq -r '.pushedAt')

            # Opcional: Formatar a data de forma mais amig√°vel (pode ser complexo em shell puro)
            # Para simplicidade, usaremos a data ISO
            # DATE_FORMATTED=$(date -d "$PUSHED_AT_ISO" "+%d/%m/%Y") # Exemplo Linux date

            # Monta o conte√∫do Markdown
            README_CONTENT="‚ú® **[\`${REPO_NAME}\`](${REPO_URL})**"
            if [ "$REPO_DESC" != "null" ]; then
              README_CONTENT+="\n\n> ${REPO_DESC}"
            fi
             README_CONTENT+="\n\nüîó [Ver Reposit√≥rio](${REPO_URL})"
            if [ "$STAR_COUNT" -gt 0 ]; then
               README_CONTENT+=" | ‚≠ê ${STAR_COUNT}"
            fi
            if [ "$LANGUAGE" != "null" ]; then
               README_CONTENT+=" | üõ†Ô∏è ${LANGUAGE}"
            fi
            README_CONTENT+=" | üóìÔ∏è √öltima atualiza√ß√£o: ${PUSHED_AT_ISO%%T*}" # Remove a parte do tempo

            # Define a sa√≠da do passo para ser usada depois
            echo "::set-output name=readme_content::$README_CONTENT"
          fi

      - name: Update README.md # Passo para editar o arquivo README
        # Usa um script sed (Linux) para encontrar os marcadores e substituir o conte√∫do
        # Este script √© sens√≠vel aos marcadores exatos e run: |
          README_FILE="README.md"
          START_MARKER=""
          END_MARKER=""
          # Obt√©m o conte√∫do gerado no passo anterior
          NEW_CONTENT="${{ steps.fetch-last-updated-repo.outputs.readme_content }}"

          # Escapa caracteres especiais para o sed (ex: &, /, \)
          ESCAPED_NEW_CONTENT=$(echo "$NEW_CONTENT" | sed 's/[\&/\]/\\&/g')

          # Usa sed para substituir o bloco entre os marcadores
          # Explica√ß√£o do sed:
          # -i: edita o arquivo in-place
          # /${START_MARKER}/,/${END_MARKER}/: seleciona o bloco entre as duas regex
          # c\\: substitui o bloco pela pr√≥xima linha(s)
          # ${START_MARKER}\\n: Insere o marcador de in√≠cio
          # ${ESCAPED_NEW_CONTENT}\\n: Insere o novo conte√∫do (com quebras de linha escapadas)
          # ${END_MARKER}: Insere o marcador de fim
          sed -i "/${START_MARKER}/,/${END_MARKER}/c\\${START_MARKER}\\n${ESCAPED_NEW_CONTENT}\\n${END_MARKER}" "$README_FILE"

      - name: Commit and push changes # Passo para commitar e enviar as altera√ß√µes
        run: |
          git config user.name github-actions # Configura o usu√°rio do commit
          git config user.email github-actions@github.com # Configura o email do commit
          git add README.md # Adiciona o README.md para commit
          git commit -m "ü§ñ Update last updated repo card" || echo "No changes to commit" # Commita se houver mudan√ßas, ignora se n√£o houver
          git push # Envia as mudan√ßas